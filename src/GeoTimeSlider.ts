import type { Selection, BaseType, HierarchyNode, ScaleLinear } from "d3";
import { partition, stratify, select, drag, scaleLinear, axisTop } from "d3";
import type {
  GeoTimeSliderOptions,
  IntervalItem,
  SliderNodeItem,
  SliderTickNode,
} from "./typing";
import { getTextWidth, trans } from "./helpers";

const DefaultOpts: Partial<GeoTimeSliderOptions> = {
  height: 400,
  fontSize: 12,
  fontFamily: "sans-serif",
  margin: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
  },
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
  },
  transition: 300,
  intervalSum: (d) => (d.leaf ? d.start - d.end : 0),
  neighborWidth: 100,
  tickLength: 15,
  tickHeight: 30,
  unit: "",
};

export default class GeoTimeSlider {
  /** text font */
  readonly font: string;
  /** svg object */
  readonly svg;
  /** interval data */
  readonly intervals: IntervalItem[];
  /** hierarchical data generated by intervals */
  readonly hierarchicalData: HierarchyNode<IntervalItem>;
  /** the root hierarchical data */
  readonly root: SliderNodeItem;
  /** user input options */
  readonly options: Required<GeoTimeSliderOptions>;
  private _onChange?: (timeRange: number[]) => void;
  private _ready: boolean = false;
  private _cellGroup!: Selection<SVGGElement, unknown, null, undefined>;
  private _cell!: Selection<
    SVGGElement | BaseType,
    SliderNodeItem,
    SVGGElement,
    unknown
  >;
  private _text!: Selection<SVGTextElement, SliderNodeItem, SVGGElement, unknown>;
  /** get or set animation transition time */
  transition: number;
  private _focus?: SliderNodeItem;
  private _tickLength: number;
  private _ticksGroup!: Selection<SVGGElement, unknown, null, undefined>;
  // 我们将创建两个drag滑块，所以我们需要两个句柄-handle1和handle2
  private _handle1!: Selection<SVGSVGElement, unknown, null, undefined>;
  private _handle2!: Selection<SVGSVGElement, unknown, null, undefined>;
  private _slider!: Selection<SVGRectElement, unknown, null, undefined>;
  private _timeLine!: ScaleLinear<number, number>;
  private _tickHeight: number;
  private _handle1X!: number;
  private _handle2X!: number;
  readonly startEnd: number[];

  /**
   * Create a GeoTimeSlider
   * @param {string | BaseType} selector CSS selector string
   * @param {IntervalItem[]} intervals geo time intervals array
   * @param {number} [options.width] svg width, defaults to container's width
   * @param {number} [options.height = 400] svg height, defaults to 400px
   * @param {number} [options.fontSize = 12] font size, defaults to 12px
   * @param {string} [options.fontFamily = 'sans-serif'] font family, defaults to 'sans-serif'
   * @param {Function} [options.onChange] callback when focused node change
   * @param {Object} [options.margin] svg margin, defaults to { top: 0, right: 0, bottom: 0, left: 0 }
   * @param {Object} [options.padding] svg padding, defaults to { top: 0, right: 0, bottom: 0, left: 0 }
   * @param {number} [options.transition = 300] animation time, defaults to 300ms
   * @param {Function} [options.intervalSum] interval transform setting, defaults to d => d.leaf ? d.start - d.end : 0
   * @param {boolean} [options.simplify = true] simplify show 2 levels or not
   * @param {number} [options.neighborWidth = 100] focused node's neighbor node width, defaults to 100px
   * @param {number} [options.tickLength = 15] tick length, defaults to 15px
   * @param {number} [options.tickHeight = 30] tick height, defaults to 30px
   * @param {string} [options.unit = ''] tick value unit
   */
  constructor(
    selector: string | BaseType,
    intervals: IntervalItem[],
    options: GeoTimeSliderOptions = {},
  ) {
    const selection = select(selector as BaseType);
    if (!selection.node()) {
      throw Error("Invalid selecor!");
    }
    if (!intervals?.length) {
      throw Error("Empty intervals !");
    }

    const containerWidth = +selection.style("width").split("px")[0];
    const opts = {
      ...DefaultOpts,
      margin: {
        ...DefaultOpts.margin,
        ...options.margin,
      },
      padding: {
        ...DefaultOpts.padding,
        ...options.padding,
      },
      width: isNaN(containerWidth) ? 1000 : containerWidth,
      ...options,
    } as Required<GeoTimeSliderOptions>;

    const { width, height, intervalSum, onChange, transition, tickLength } =
      opts;

    this.transition = transition;
    this._onChange = onChange;
    this.font = `${opts.fontSize}px ${opts.fontFamily}`;
    this.intervals = intervals;
    this._tickLength = tickLength;

    this.options = opts;

    this.hierarchicalData = stratify<IntervalItem>()(intervals)
      .sum(intervalSum)
      .sort((a, b) => b.data.start - a.data.start);

    this.root = partition<IntervalItem>()
      .size([width, height - opts.margin.bottom - opts.margin.top])
      .padding(0)(this.hierarchicalData);

    this.root.each((d) => {
      d.visible = true;
    });

    // 定义刻度条高度。
    this._tickHeight = opts.tickHeight;

    // 更新 SVG 的视图框（viewBox）以容纳刻度条。
    this.svg = selection
      .append("svg")
      .attr("viewBox", [
        0,
        -this._tickHeight,
        opts.width,
        opts.height + this._tickHeight,
      ])
      .style("font", this.font);

    this.startEnd = [this.root.data.start, this.root.data.end];

    this._drawTimeScale();

    this._clicked(undefined, this.root);

    this._ready = true;
  }

  /** get or set focused stage
   * @example
   * geoTimeScale.stage = 'Cambrian'
   */
  get stage(): string | undefined {
    return this._focus?.data.name;
  }

  set stage(val: string) {
    const node = this.root.find((node) => node.data.name === val);
    if (node) {
      this._clicked(undefined, node);
    }
  }

  get sliderPosition() {
    const x1 = Math.min(this._handle1X, this._handle2X);
    const x2 = Math.max(this._handle1X, this._handle2X);
    return [x1, x2];
  }

  get timeRange() {
    return [
      +this._timeLine.invert(this.sliderPosition[0]).toFixed(3),
      +this._timeLine.invert(this.sliderPosition[1]).toFixed(3),
    ];
  }

  set timeRange(range: number[]) {
    this._handle1X = this._timeLine(range[0]);
    this._handle2X = this._timeLine(range[1]);
    this._updateSlider(true);
  }

  get ready(): boolean {
    return this._ready;
  }

  private _drawTimeScale() {
    const svg = this.svg;

    this._timeLine = scaleLinear()
      .domain(this.startEnd)
      .range([0, this.options.width])
      .clamp(true);

    // 添加刻度条
    this.svg.append("g").attr("id", "timeline").call(axisTop(this._timeLine));

    // draw cells
    this._cellGroup = svg.append("g").attr("id", "cells");

    this._cell = this._cellGroup
      .selectAll("g")
      .data(this.root.descendants())
      .join("g")
      .attr("transform", (d) => `translate(0, ${d.y0})`);

    this._drawRect(this._cell).on("click", this._clicked);

    this._addTitle(this._cell);

    // draw text
    this._text = this._drawText(this._cell);
    // draw ticks
    this._ticksGroup = svg.append("g").attr("id", "ticks");
    this._ticksGroup.call((g) => this._addTicks(g, this._makeTicksData()));

    // 创建滑条
    this._slider = this._createSlider();

    // 创建滑块
    this._handle1 = this._createHandle(
      this._timeLine(this.startEnd[0]),
      "left",
    );
    this._handle2 = this._createHandle(
      this._timeLine(this.startEnd[1]),
      "right",
    );
    this._handle1X = this.root.x0;
    this._handle2X = this.root.x1;

    this._ready = true;
  }

  // 创建可拖动的句柄
  private _createHandle(initialX: number, position: "left" | "right") {
    const svgIcon = `<g>
 <defs>
  <symbol height="24" id="svg_1" viewBox="0 0 123 24" width="123" xmlns="http://www.w3.org/2000/svg">
   <path d="m3,17.8301l0,-11.66002c0.00514,-0.1598 0.04191,-0.31699 0.10817,-0.4625c0.06626,-0.14551 0.1607,-0.27644 0.27786,-0.38524c0.11716,-0.10879 0.25472,-0.19329 0.40473,-0.2486c0.15001,-0.05531 0.3095,-0.08035 0.46924,-0.07366l8.39,0c0.229,-0.00096 0.4514,0.0767 0.63,0.22l7.22,5.85002c0.1548,0.1008 0.2819,0.2387 0.3699,0.4011c0.088,0.1624 0.1341,0.3442 0.1341,0.5289c0,0.1847 -0.0461,0.3665 -0.1341,0.5289c-0.088,0.1624 -0.2151,0.3002 -0.3699,0.4011l-7.22,5.85c-0.1786,0.1433 -0.401,0.2209 -0.63,0.22l-8.39,0c-0.15974,0.0067 -0.31923,-0.0184 -0.46924,-0.0737c-0.15001,-0.0553 -0.28757,-0.1398 -0.40473,-0.2486c-0.11717,-0.1088 -0.21161,-0.2397 -0.27786,-0.3852c-0.06626,-0.1455 -0.10303,-0.3027 -0.10817,-0.4625z" fill="#F25B28"/>
  </symbol>
 </defs>
 <g class="layer">
  <use id="svg_2" transform="rotate(90 9.62596 78.61) matrix(1.30081 0 0 1.30081 -72 63)" x="0" xlink:href="#svg_1" y="0"/>
  <g id="svg_3"/>
 </g>
</g>
      `;

    const imageWidth = 20; // SVG 图标的宽度

    const handle = this.svg
      .append("svg")
      .html(svgIcon)
      .attr("width", imageWidth)
      .attr("x", initialX - imageWidth / 2)
      .attr("y", -24)
      .style("cursor", "grab");

    handle
      .append("rect")
      .attr("width", 4)
      .attr("height", this.options.height + 2)
      .attr("x", imageWidth / 2 - 2)
      .attr("y", 22)
      .attr("fill", "#F25B28");

    const dragBehavior = drag().on("drag", (event) => {
      const newX = this._getX(event.x);
      if (position === "left") {
        this._handle1X = newX;
      } else {
        this._handle2X = newX;
      }

      this._updateSlider();
    });

    handle.call(dragBehavior as any);
    return handle;
  }

  private _getX(x: number) {
    let newX = x;
    newX = Math.min(newX, this.options.width);
    newX = Math.max(newX, 0);
    return newX;
  }

  // 创建滑条
  private _createSlider() {
    const slider = this.svg
      .append("g")
      .append("rect")
      .attr("height", this._tickHeight)
      .attr("fill", "#F25B2833")
      .attr("y", -this._tickHeight)
      .style("cursor", "move");

    const dragBehavior = drag().on("drag", (event) => {
      const dx = event.dx;
      if (
        this.sliderPosition[0] + dx < 0 ||
        this.sliderPosition[1] + dx > this.options.width
      ) {
        return;
      }
      this._handle1X = this._getX(this._handle1X + dx);
      this._handle2X = this._getX(this._handle2X + dx);

      this._updateSlider();
    });

    slider.call(dragBehavior as any);

    return slider;
  }

  // 更新滑块和滑条位置
  private _updateSlider(animate = false) {
    const duration = animate ? this.transition : 0; // initial without transition

    trans(this._handle1, duration).attr("x", this._handle1X - 20 / 2);
    trans(this._handle2, duration).attr("x", this._handle2X - 20 / 2);
    trans(this._slider, duration)
      .attr("width", Math.abs(this._handle2X - this._handle1X))
      .attr("x", this.sliderPosition[0]);
    if (this.ready) {
      this._onChange?.(this.timeRange);
    }

    if (!animate) {
      this._focus = undefined;
    }
    this._updateText();
  }

  private _addTitle(cell: typeof this._cell) {
    return cell.append("title").text((d) => {
      const sequence = d
        .ancestors()
        .map((d) => d.data.name)
        .reverse();

      return `${sequence.join(" > ")}`;
    });
  }

  /**
   * draw rect
   */
  private _drawRect(cell: typeof this._cell) {
    return cell
      .append("rect")
      .attr("x", (d) => d.x0)
      .attr("width", (d) => d.x1 - d.x0)
      .attr("height", (d) => (d.visible ? d.y1 - d.y0 : 0))
      .attr("fill", (d) => d.data.color)
      .attr("stroke", "white")
      .attr("stroke-width", 0.5)
      .attr("cursor", "pointer")
      .on("pointerenter", (_event, d) => {
        // Get the ancestors of the current segment
        const sequence = d.ancestors().reverse();
        // Highlight the ancestors
        cell.attr("fill-opacity", (d) => (sequence.includes(d) ? 1.0 : 0.5));
      })
      .on("pointerleave", () => {
        cell.attr("fill-opacity", 1);
      });
  }

  /** draw text */
  private _drawText(cell: typeof this._cell) {
    const text = cell
      .append("text")
      .style("user-select", "none")
      .attr("pointer-events", "none")
      .attr("fill", (d) => d.data.textColor ?? "black")
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "middle")
      .attr("fill-opacity", (d) => +(d.x1 - d.x0 > 14))
      .attr("x", (d) => {
        // Position all the ancestors labels in the middle
        const textX = d.x0 + (d.x1 - d.x0) / 2;
        return Number.isNaN(textX) ? 0 : textX;
      })
      .attr("y", (d) => (d.y1 - d.y0) / 2)
      .attr("opacity", (d) => (d.visible ? 1 : 0))
      .attr("font-size", this.options.fontSize)
      .attr("font-weight", 500)
      .text((d) => {
        const rectWidth = Math.abs(d.x1 - d.x0);
        const labelWidth = getTextWidth(d.data.name, this.font);
        const abbrev = d.data.abbr || d.data.name.charAt(0);

        return rectWidth - 8 < labelWidth ? abbrev : d.data.name;
      });

    return text;
  }

  private _makeTicksData(): SliderTickNode[] {
    const ticksData = this.root.descendants().map((d) => {
      let visible = d.visible ?? false;

      if (visible) {
        if (d.parent?.visible && d.data.start === d.parent.data.start) {
          visible = false;
        } else {
          const text = d.data.start + this.options.unit;
          const rectWidth = d.x1 - d.x0;
          const labelWidth = getTextWidth(text, this.font);

          visible = rectWidth >= labelWidth * (1 - 0.05 * (d.data.level ?? 0));
        }
      }

      return {
        x: d.x0,
        y: d.y0,
        depth: d.depth,
        text: d.data.start + this.options.unit,
        visible,
      };
    });

    const now = {
      x: this.root.x1,
      y: 0,
      depth: 0,
      text: "0",
      visible: true,
    };

    ticksData.push(now);

    return ticksData;
  }

  // 添加方块中的刻度
  private _addTicks(ticks: typeof this._ticksGroup, data: SliderTickNode[]) {
    ticks
      .selectAll("g")
      .data(data)
      .join(
        // @ts-ignore
        (enter) => {
          const tick = enter.append("g");

          tick
            .append("line")
            .attr("stroke", "#555")
            .attr("stroke-width", 1)
            .attr("x1", 0)
            .attr("y1", 0)
            .attr("x2", 0)
            .attr("y2", this._tickLength);

          tick
            .append("text")
            .attr("x", 0)
            .attr("y", this._tickLength + this.options.fontSize / 2)
            .attr("font-size", (d) => `${1 - 0.05 * d.depth}em`)
            .text((d) => d.text)
            .clone(true)
            .lower()
            .attr("stroke-linejoin", "round")
            .attr("stroke-width", 2)
            .attr("stroke", "white");

          tick
            .attr("opacity", (d) => (d.visible ? 1 : 0))
            .attr("display", (d) => (d.visible ? "block" : "none"))
            .attr("transform", (d) => `translate(${d.x}, ${d.y})`)
            .attr("dominant-baseline", "hanging")
            .attr("text-anchor", (d) =>
              d.x === 0 ? "start" : d.x >= this.root.x1 ? "end" : "middle",
            );
        },
      );
  }

  // 更新选中节点的文字样式
  private _updateText() {
    const duration = this._ready ? this.transition : 0; // initial without transition

    trans(this._text, duration)
      .attr("font-size", (d) =>
        d.id === this._focus?.id
          ? this.options.fontSize + 2
          : this.options.fontSize,
      )
      .attr("font-weight", (d) => (d.id === this._focus?.id ? "bold" : 500));
  }

  /**
   * click rect and zoom
   */
  private _clicked = (_event: any, p: SliderNodeItem): boolean => {
    const focus = p === this._focus ? p?.parent ?? p : p;
    this._focus = focus;

    this._handle1X = focus.x0;
    this._handle2X = focus.x1;
    this._updateSlider(true);

    return true;
  };
}
